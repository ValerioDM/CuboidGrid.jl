var documenterSearchIndex = {"docs":
[{"location":"index.html#Aim-of-the-progect","page":"Home","title":"Aim of the progect","text":"","category":"section"},{"location":"index.html#CuboidGrids-is-the-result-of-the-work-of-the-pre-existing-package-[LinearAlgebraicRepresetation](https://github.com/cvdlab/LinearAlgebraicRepresentation.jl).","page":"Home","title":"CuboidGrids is the result of the work of the pre-existing package LinearAlgebraicRepresetation.","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The aim of the project is to optimize the package for the voxellization, using parallel computing techniques such as multithrerading and/or sitribution. The package contains 3 files, CuboidGrids,jl for the dipendences, struct.jl and largrid.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Voxellization is a process by which specific data structure are made. These data structure represent informations in a way that can be visualized in a 2- ore 3-dimensional render, thanks to the help of other package. For the voxellixaion is such a \"hidden\" concept without the graphic result, an example file has been given for the project. This file contain function for the data processing before the visualization, which are introducedin the new package as well. The parallelization has been implemented in several ways such as the @spawn macro, the @Threads macro or the pmap function. Unfotunally, no improvement has been analized. Even if the number of threads is set right, as well as the numer of workers for the distribution, the result of the analisis made with the btime macro shows not only no improvement at all, but a small downgrade of the performance, as showed below:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: btimeLog1.jpg)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"(Image: btimeLog2.jpg)","category":"page"},{"location":"CuboidGrids.html#CuboidGrids","page":"CuboidGrids","title":"CuboidGrids","text":"","category":"section"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"This file contains all the dependencies, the data structs used in the data process. Has been added some functions (bottom page) from the voxellization example file so the voxel/render files will eventually contains less strings, resulting in a much better looking code.","category":"page"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"##Main interface","category":"page"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.Points","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.Points","page":"CuboidGrids","title":"CuboidGrids.Points","text":"Points = Array{Number,2}\n\nAlias declation of LAR-specific data structure. Dense Array{Number,2,1} M x N to store the position of vertices (0-cells) of a cellular complex. The number of rows M is the dimension of the embedding space. The number of columns N is the number of vertices.\n\n\n\n\n\n","category":"type"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.Cells","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.Cells","page":"CuboidGrids","title":"CuboidGrids.Cells","text":"Cells = Array{Array{Int,1},1}\n\nAlias declation of LAR-specific data structure. Dense Array to store the indices of vertices of P-cells of a cellular complex. The linear space of P-chains is generated by Cells as a basis. Simplicial P-chains have P+1 vertex indices for cell element in Cells array. Cuboidal P-chains have 2^P vertex indices for cell element in Cells array. Other types of chain spaces may have different numbers of vertex indices for cell element in Cells array.\n\n\n\n\n\n","category":"type"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.Chain","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.Chain","page":"CuboidGrids","title":"CuboidGrids.Chain","text":"Chain = SparseArrays.SparseVector{Int8,Int}\n\nAlias declation of LAR-specific data structure. Binary SparseVector to store the coordinates of a chain of N-cells. It is nnz=1 with value=1 for the coordinates of an elementary N-chain, constituted by a single N-chain.\n\n\n\n\n\n","category":"type"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.ChainOp","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.ChainOp","page":"CuboidGrids","title":"CuboidGrids.ChainOp","text":"ChainOp = SparseArrays.SparseMatrixCSC{Int8,Int}\n\nAlias declation of LAR-specific data structure. SparseMatrix in Compressed Sparse Column format, contains the coordinate representation of an operator between linear spaces of P-chains. Operators P-Boundary  P-Chain - (P-1)-Chain and P-Coboundary  P-Chain - (P+1)-Chain are typically stored as ChainOp with elements in -101 or in 01, for signed and unsigned operators, respectively.\n\n\n\n\n\n","category":"type"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.ChainComplex","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.ChainComplex","page":"CuboidGrids","title":"CuboidGrids.ChainComplex","text":"ChainComplex = Array{ChainOp,1}\n\nAlias declation of LAR-specific data structure. It is a 1-dimensional Array of ChainOp that provides storage for either the chain of boundaries (from D to 0) or the transposed chain of coboundaries (from 0 to D), with D the dimension of the embedding space, which may be either R^2 or R^3.\n\n\n\n\n\n","category":"type"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.LARmodel","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.LARmodel","page":"CuboidGrids","title":"CuboidGrids.LARmodel","text":"LARmodel = Tuple{Points,Array{Cells,1}}\n\nAlias declation of LAR-specific data structure. LARmodel is a pair (Geometry, Topology), where Geometry is stored as Points, and Topology is stored as Array of Cells. The number of Cells values may vary from 1 to N+1.\n\n\n\n\n\n","category":"type"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.LAR","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.LAR","page":"CuboidGrids","title":"CuboidGrids.LAR","text":"LAR = Union{ Tuple{Points, Cells},Tuple{Points, Cells, Cells} }\n\nAlias declation of LAR-specific data structure. LAR is a pair (Geometry, Topology), where Geometry is stored as Points, and Topology is stored as Cells.\n\n\n\n\n\n","category":"type"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.approxVal","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.approxVal","page":"CuboidGrids","title":"CuboidGrids.approxVal","text":"approxVal(PRECISION)(value)\n\nTransform the float value to get a PRECISION number of significant digits.\n\n\n\n\n\n","category":"function"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.CV2FV","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.CV2FV","page":"CuboidGrids","title":"CuboidGrids.CV2FV","text":"CV2FV( Array{Int64} ) Array{Int64}  Return the vertices cells array tranformed to a vertices faces array\n\n\n\n\n\n","category":"function"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.K","category":"page"},{"location":"CuboidGrids.html#CuboidGrids.K","page":"CuboidGrids","title":"CuboidGrids.K","text":"K( Array{Int64} ) Return the sparse matrix built with the passed array\n\n\n\n\n\n","category":"function"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.VEF","category":"page"},{"location":"CuboidGrids.html","page":"CuboidGrids","title":"CuboidGrids","text":"CuboidGrids.Mats","category":"page"},{"location":"largrid.html#largrid","page":"largrid.jl","title":"largrid","text":"","category":"section"},{"location":"largrid.html","page":"largrid.jl","title":"largrid.jl","text":"This file is the heart of the project. Itit contains the function used for the voxellization process. The parallelization has been implemented intially with the pmap function. Another attempt was to diassamble the the functions and parallelize them with the @thread macro. This attempt was almost istantly discarded because it would mean make the same function more complicated, adding computational time. The whole process start from the call of the cuboidGrid function, which only need the shape of the data that is wanted to be voxellized. From the shape will be extracted the vertices array and the cells array.","category":"page"},{"location":"largrid.html#Function-list","page":"largrid.jl","title":"Function list","text":"","category":"section"},{"location":"largrid.html","page":"largrid.jl","title":"largrid.jl","text":"CuboidGrids.larVertProd","category":"page"},{"location":"largrid.html#CuboidGrids.larVertProd","page":"largrid.jl","title":"CuboidGrids.larVertProd","text":"larVertProd(vertLists::Array{Points,1})::Points\n\nGenerate the integer coordinates of vertices (0-cells) of a multidimensional grid. Grid n-vertices are produced by the larVertProd function, via Cartesian product of vertices of n 0-dimensional arguments (vertex arrays in vertLists), orderly corresponding to x_1 x_2  x_n coordinates in the output points (x_1 x_2x_n) in R^n.\n\n#\tExample\n\njulia> larVertProd([ larGrid(3)(0), larGrid(4)(0) ])\n# output\n2×20 Array{Int64,2}:\n 0  0  0  0  0  1  1  1  1  1  2  2  2  2  2  3  3  3  3  3\n 0  1  2  3  4  0  1  2  3  4  0  1  2  3  4  0  1  2  3  4\n\n\n\n\n\n","category":"function"},{"location":"largrid.html","page":"largrid.jl","title":"largrid.jl","text":"CuboidGrids.larImageVerts","category":"page"},{"location":"largrid.html#CuboidGrids.larImageVerts","page":"largrid.jl","title":"CuboidGrids.larImageVerts","text":"larImageVerts(shape::Array{Int,1})::Array{Int64,2}\n\nLinearize the grid of integer vertices, given the shape of a cuboidal grid (typically an image).\n\nExamples\n\njulia> larImageVerts([1024,1024])\n# output\n2×1050625 Array{Int64,2}:\n 0  0  0  0  0  0  0  0  0  0   0   0 … 1024  1024  1024  1024  1024  1024  1024  1024\n 0  1  2  3  4  5  6  7  8  9  10  11 … 1017  1018  1019  1020  1021  1022  1023  1024\n\njulia> larImageVerts([1,1,1])\n# output\n3×8 Array{Int64,2}:\n 0  0  0  0  1  1  1  1\n 0  0  1  1  0  0  1  1\n 0  1  0  1  0  1  0  1\n\n\n\n\n\n","category":"function"},{"location":"largrid.html","page":"largrid.jl","title":"largrid.jl","text":"CuboidGrids.filterByOrder","category":"page"},{"location":"largrid.html#CuboidGrids.filterByOrder","page":"largrid.jl","title":"CuboidGrids.filterByOrder","text":"filterByOrder( n::Int )Array{Array{Array{Int8,1},1},1}\n\nFilter the array of codes  (Boolean String) of n bits depending on their integer value (order).\n\nExample\n\njulia> filterByOrder(3)\n# output\n4-element Array{Array{Array{Int8,1},1},1}:\n Array{Int8,1}[Int8[0, 0, 0]]\n Array{Int8,1}[Int8[0, 0, 1], Int8[0, 1, 0], Int8[1, 0, 0]]\n Array{Int8,1}[Int8[0, 1, 1], Int8[1, 0, 1], Int8[1, 1, 0]]\n Array{Int8,1}[Int8[1, 1, 1]]\n\n\n\n\n\n","category":"function"},{"location":"largrid.html","page":"largrid.jl","title":"largrid.jl","text":"CuboidGrids.larCellProd","category":"page"},{"location":"largrid.html#CuboidGrids.larCellProd","page":"largrid.jl","title":"CuboidGrids.larCellProd","text":"larCellProd(cellLists::Array{Cells,1})::Cells\n\nGeneration of grid cells by Cartesian product of 0/1-complexes. The output complex is generated by the product of any number of either 0- or 1-dimensional cell complexes. The product of d 1-complexes generates solid d-cells, while the product of n 0-complexes and d-n 1-complexes (n  d) generates non-solid (d-n)-cells, properly embedded in d-space, i.e. with vertices having d coordinates.\n\nExamples\n\nTo understand the generation of cuboidal grids from products of 0- or 1-dimensional complexes, below we show a simple example of 2D grids embedded in R^3. In particular, v1 = [0. 1. 2. 3.] and v0 = [0. 1. 2.] are two 2-arrays of 1D vertices, c1 = [[0,1],[1,2],[2,3]] and c0 = [[0],[1],[2]] are the LAR representation of one 1-complex and one 0-complex, respectively. The solid 2-complex named grid2D is generated in 2D as follows:\n\njulia> v1 = [0. 1. 2. 3.]\n1×4 Array{Float64,2}:\n 0.0  1.0  2.0  3.0\n\njulia> c1 = [[0,1],[1,2],[2,3]]\n3-element Array{Array{Int64,1},1}:\n [0, 1]\n [1, 2]\n [2, 3]\n\njulia> grid2D = larVertProd([v1,v1]),larCellProd([c1,c1])\n([0.0 0.0 … 3.0 3.0; 0.0 1.0 … 2.0 3.0], Array{Int64,1}[[1, 2, 5, 6], [2, 3, 6, 7], [3, 4, 7, 8], [5, 6, 9, 10], [6, 7, 10, 11], [7, 8, 11, 12], [9, 10, 13, 14], [10, 11, 14, 15], [11, 12, 15, 16]])\n\nwhereas a non-solid 2-complex in 3D is generated as:\n\njulia> v1, c1 = [0. 1. 2. 3.],[[0,1],[1,2],[2,3]]\n([0.0 1.0 2.0 3.0], Array{Int64,1}[[0, 1], [1, 2], [2, 3]])\n\njulia> v0, c0 = [0. 1. 2.], [[0],[1],[2]]\n([0.0 1.0 2.0], Array{Int64,1}[[0], [1], [2]])\n\njulia> vertGrid = larVertProd([v1, v1, v0])\n3×48 Array{Float64,2}:\n 0.0  0.0  0.0  0.0  0.0  0.0  …  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0  3.0\n 0.0  0.0  0.0  1.0  1.0  1.0  …  1.0  1.0  1.0  2.0  2.0  2.0  3.0  3.0  3.0\n 0.0  1.0  2.0  0.0  1.0  2.0  …  0.0  1.0  2.0  0.0  1.0  2.0  0.0  1.0  2.0\n\njulia> cellGrid = larCellProd([c1, c1, c0])\n27-element Array{Array{Int64,1},1}:\n [1, 4, 13, 16]\n [2, 5, 14, 17]\n ...  ... ...\n [32, 35, 44, 47]\n [33, 36, 45, 48]\n\njulia> grid3D = vertGrid,cellGrid\n([0.0 0.0 … 3.0 3.0; 0.0 0.0 … 3.0 3.0; 0.0 1.0 … 1.0 2.0], Array{Int64,1}[[1, 4, 13, 16], [2, 5, 14, 17], … [32, 35, 44, 47], [33, 36, 45, 48]])\n\njulia> using Plasm\n\njulia> Plasm.view(grid3D)\n\n\n\n\n\n","category":"function"},{"location":"largrid.html","page":"largrid.jl","title":"largrid.jl","text":"CuboidGrids.larGridSkeleton","category":"page"},{"location":"largrid.html#CuboidGrids.larGridSkeleton","page":"largrid.jl","title":"CuboidGrids.larGridSkeleton","text":"larGridSkeleton( shape::Array{Int,1} )( d::Int )::Cells\n\nProduce the d-dimensional skeleton (set of d-cells) of a cuboidal grid of given shape.\n\nExample\n\nA shape=[1,1,1] parameter refers to a grid with a single step on the three axes, i.e. to a single 3D unit cube. Below all skeletons of such simplest grid are generated.\n\njulia> Lar.larGridSkeleton([1,1,1])(0)\n# output\n8-element Array{Array{Int64,1},1}:\n[[1], [2], [3], [4], [5], [6], [7], [8]]\n\njulia> Lar.larGridSkeleton([1,1,1])(1)\n# output\n12-element Array{Array{Int64,1},1}:\n[[1,2],[3,4],[5,6],[7,8],[1,3],[2,4],[5,7],[6,8],[1,5],[2,6],[3,7],[4,8]]\n\njulia> Lar.larGridSkeleton([1,1,1])(2)\n# output\n6-element Array{Array{Int64,1},1}:\n[[1,2,3,4], [5,6,7,8], [1,2,5,6], [3,4,7,8], [1,3,5,7], [2,4,6,8]]\n\njulia> Lar.larGridSkeleton([1,1,1])(3)\n# output\n1-element Array{Array{Int64,1},1}:\n [1, 2, 3, 4, 5, 6, 7, 8]\n\n\n\n\n\n","category":"function"},{"location":"largrid.html","page":"largrid.jl","title":"largrid.jl","text":"CuboidGrids.cuboidGrid","category":"page"},{"location":"largrid.html#CuboidGrids.cuboidGrid","page":"largrid.jl","title":"CuboidGrids.cuboidGrid","text":"cuboidGrid( shape, filled=false )::Union( Cells, Array{Cells,1} )\n\nMulti-dimensional generator function. Generate either a solid d-grid of unit d-cuboids in d-dimensional space, or the array of p-skeletons (0 =p= d), depending on the Boolean variable filled. 0-cuboids are points, 1-cuboids are segments, , 2-cuboids are squares,  3-cuboids are cubes, etc. The shape=[a,b,c] value determines the number a x b x c of d-cells. Notice that d = length(shape)\n\n\n\n\n\n","category":"function"}]
}
